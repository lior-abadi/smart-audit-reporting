<br> <h3>L-1 Insufficient protection of sensitive data</h3><br>The `hardhat.config.ts` uses sensitive information imported from an un-committed environment file. The usage of either `.env` imported variables or even plain pasted keys make it easier for an attacker to compromise the keys used for monitoring, deployment, testing and even if wallet private keys are used in such way funds can be compromised. The following data could be compromised if a leak happens or if the `.gitignore` file is mistakenly deleted according to the imports performed on `hardhat.config.ts`: <br><br><em>Found 1 time</em><br><br>`Emitter.sol L29  address indexed signer,` <br><br><br> <h3>L-2 Using abi.encodePacked before hashing for dynamic values can lead to hash collisions</h3><br>The mentioned function concatenates directly types that are shorter than 32 bytes without padding or sign extending the value. For further information, the following link of the [official doc](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#non-standard-packed-mode) can be checked. Essentially, it is recommended using `abi.encode()` instead of `encodePacked()` because the first one pads the values across `32 bytes`.  According to the cited link: >If you use `keccak256(abi.encodePacked(a, b))` and both a and b are dynamic types, it is easy to craft collisions in the hash value by moving parts of a into b and vice-versa. More specifically, `abi.encodePacked("a", "bc") == abi.encodePacked("ab", "c")`. If you use abi.encodePacked for signatures, authentication or data integrity, make sure to always use the same types and check that at most one of them is dynamic. Unless there is a compelling reason, abi.encode should be preferred.<br><br><em>Found 2 times</em><br><br>`Emitter.sol L30  uint256 orderType,` <br>`Emitter.sol L31  uint256 totalAmt,` <br><br>